#!/usr/bin/env bash

# Get the script's directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

#####################################################################
# FUNCTIONS:
# GITHUB_USER is declared in the '.env' file.
#####################################################################

function list-functions() {
    # Exclusions: 'function _'
    grep -E '^function\s+[a-zA-Z_-][a-zA-Z0-9_-]*\s*\(\)\s*{' "$SCRIPT_DIR/.functions" | grep -v -E '^function\s+_' | awk '{print ">> " $2}'
}

function pathsXX() {
    echo $PATH | tr ':' '\n' | sed 's/^/\t/'
}

function paths() {
    IFS=':' read -ra PATHS <<< "$PATH"
    for p in "${PATHS[@]}"; do
        ctxt yellow "\t $p"
    done
}

function show-env() {
    ctxt yellow ">> GITHUB_USER = $GITHUB_USER"
    ctxt yellow ">> BASE_PATH   = $BASE_PATH"
    ctxt yellow ">> MVN_HOME    = $MVN_HOME"
    ctxt yellow ">> JAVA_HOME   = $JAVA_HOME"
    ctxt yellow ">> PATH = "
    paths
}

function start() {
    nohup $1 &> /dev/null & disown;
}

# Create a new directory and enter it
function mkd() {
    mkdir -p -- "$@" && cd -P -- "${@: -1}"
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}

function filesize() {
    du -sk * | sort -n
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

#####################################################################
# GIT functions
#####################################################################

function git-set-config() {
    git config --list

    question "Enter Git fullname:"
    read USER_NAME
    info "Requesting root permissions to set git config at system level..."
    sudo git config --system user.name $USER_NAME

    question "Enter Git email address:"
    read USER_EMAIL
    info "Requesting root permissions to set git config at system level..."
    sudo git config --system user.email $USER_EMAIL

    git config --list
}

function git-init-repo() {
    if [[ -z "$1" ]]; then
        error "Repository name is empty."
        return;
    fi;

    warn "You need to create the remote repository first!"
    info "Github User is [$GITHUB_USER]"
    info "Repository name is [$1]"
    question "Press Enter to continue..."
    read

    info "git init -b main"
    git init -b main

    info "git add ."
    git add .

    info "git commit -m \"First commit\""
    git commit -m "First commit"

    info "git remote add origin git@github.com:$GITHUB_USER/$1.git"
    git remote add origin git@github.com:$GITHUB_USER/$1.git

    info "git remote -v"
    git remote -v

    info "git push -u origin main"
    git push -u origin main

    success "Success initiating git repo '$1'."
}

function gcom() {
    git add .
    git commit -m "$1"
}


#####################################################################
# Permissions
#####################################################################

function show-permissions() {
    ctxt yellow "  N   Description                      ls   binary"
    ctxt yellow "  0   No permissions at all            ---  000"
    ctxt yellow "  1   Only execute                     --x  001"
    ctxt yellow "  2   Only write                       -w-  010"
    ctxt yellow "  3   Write and execute                -wx  011"
    ctxt yellow "  4   Only read                        r--  100"
    ctxt yellow "  5   Read and execute                 r-x  101"
    ctxt yellow "  6   Read and write                   rw-  110"
    ctxt yellow "  7   Read, write, and execute         rwx  111"
}

function set-permissions() {

    if [ -z "$1" ]; then
        ctxt yellow "Usage: set-permissions <folder>"
        ctxt yellow "Example:"
        ctxt yellow "  set-permissions /path/to/folder  # Absolute path"
        ctxt yellow "  set-permissions folder           # Relative path"
        ctxt yellow "  set-permissions .                # Current folder"
        return 1
    fi

    folder="$1"

    # Check if the folder path is relative or absolute
    if [[ "$folder" != /* ]]; then
        # If it's a relative path, prepend the current working directory
        folder="$(pwd)/$folder"
    fi

    # Check if the folder exists
    if [ -d "$folder" ]; then
        
        pushd "$folder" > /dev/null || exit

        # Set permissions for directories (755)
        find . -type d -print0 | xargs -0 chmod 755

        # Set permissions for files (644)
        find . -type f -print0 | xargs -0 chmod 644

        # Make .sh files executable
        find . -type f -iname "*.sh" -exec chmod +x {} \;

        popd > /dev/null || exit

        success "Permissions have been set for the folder: $folder"
    else
        error "Folder does not exist: $folder"
        return 1
    fi
}


#####################################################################
# Utilities
#####################################################################

function create-desktop-entry() {
    question "Enter the name of the application (e.g., MyApp):"
    read -r app_name

    question "Enter the full path to the executable (e.g., /usr/bin/myapp or /opt/myapp/bin/start.sh):"
    read -r exec_path

    question "Enter the path for the application icon (e.g., /usr/share/icons/myapp.png or just 'myapp' if in icon theme):"
    read -r icon_path

    #question "Does the application run in a terminal? (true/false)"
    #read -r terminal_option
    terminal_option=false

    desktop_path="$HOME/Desktop"

    # Convert app name to lowercase
    lower_app_name=$(echo "$app_name" | tr '[:upper:]' '[:lower:]')

    # Create the content for the .desktop file
    desktop_entry_content="[Desktop Entry]
Encoding=UTF-8
Name=$app_name
Comment=$app_name
GenericName=$app_name
Exec=$exec_path
Icon=$icon_path
Terminal=$terminal_option
X-MultipleArgs=false
Type=Application
Version=1.0
StartupNotify=true"

    # Create the .desktop file on the Desktop
    desktop_file="$desktop_path/${lower_app_name}.desktop"

    # Write the content to the file
    echo "$desktop_entry_content" > "$desktop_file"

    # Make the .desktop file executable
    chmod +x "$desktop_file"

    success "Desktop entry for $app_name created at $desktop_file"
}

function show-ports() {
    sudo ss -tulpn | grep LISTEN
}

# Simple function to convert Windows to Unix line endings
function 2unix() {
    for file in "$@"; do
        if [[ -f "$file" && -w "$file" ]]; then
            sed -i 's/\r$//' "$file" && echo "Fixed: $file"
        else
            warn "Skipping: $file (not found or not writable)"
        fi
    done
}

function trim() {
    sed 's/^[ \t]*//;s/[ \t]*$//'
}

function rgrep() {
    # -I: prevent searching in binary files
    grep -Id recurse "$@"
}

function ucase() {
    tr '[:lower:]' '[:upper:]'
}

function lcase() {
    tr '[:upper:]' '[:lower:]'
}

function today() {
    date '+%d-%m-%Y'
}

#####################################################################
# Colors and messages
#####################################################################

# Better color detection with more robust checks
if command -v tput >/dev/null 2>&1; then
    # Check if we're in an interactive terminal with color support
    if [[ -t 1 ]] && [[ -n "${TERM:-}" ]] && tput colors >/dev/null 2>&1; then
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
        YELLOW=$(tput setaf 3)
        BLUE=$(tput setaf 4)
        PURPLE=$(tput setaf 5)
        CYAN=$(tput setaf 6)
        WHITE=$(tput setaf 7)
        BOLD=$(tput bold)
        UNDERLINE=$(tput smul)
        RESET=$(tput sgr0)
    else
        # Non-interactive or no color support
        RED="" GREEN="" YELLOW="" BLUE="" PURPLE="" CYAN="" WHITE=""
        BOLD="" UNDERLINE="" RESET=""
    fi
else
    # No tput available
    RED="" GREEN="" YELLOW="" BLUE="" PURPLE="" CYAN="" WHITE=""
    BOLD="" UNDERLINE="" RESET=""
fi

# Export if you want them available in subshells
#export RED GREEN YELLOW BLUE PURPLE CYAN WHITE BOLD RESET

info()     { printf "${BLUE}[>] INFO: %s ${RESET}\n" "$*"; }
warn()     { printf "${YELLOW}[!] WARN: %s ${RESET}\n" "$*" >&2; }
error()    { printf "${RED}[✗] ERROR: %s ${RESET}\n" "$*" >&2; }
success()  { printf "${GREEN}[✔] %s ${RESET}\n" "$*"; }
question() { printf "${GREEN}[?] %s ${RESET}\n" "$*"; }

ctxt() {
    local color="$1"
    shift
    case "$color" in
        red) echo -e "${RED}$*${RESET}" ;;
        green) echo -e "${GREEN}$*${RESET}" ;;
        yellow) echo -e "${YELLOW}$*${RESET}" ;;
        blue) echo -e "${BLUE}$*${RESET}" ;;
        purple) echo -e "${PURPLE}$*${RESET}" ;;
        cyan) echo -e "${CYAN}$*${RESET}" ;;
        white) echo -e "${WHITE}$*${RESET}" ;;
        bold) echo -e "${BOLD}$*${RESET}" ;;
        underline) echo -e "${UNDERLINE}$*${RESET}" ;;
        *) echo "$*" ;;  # No color
    esac
}

test-colors() {
    info "Info message."
    warn "Warn message."
    error "Error message."
    success "Success message."
    question "Question..."
}

#####################################################################