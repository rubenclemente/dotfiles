#!/usr/bin/env bash

# Terminal color detection
case "$TERM" in
    xterm-color|*-256color|screen|tmux) color_prompt=yes;;
esac

# Color setup
if tput setaf 1 &> /dev/null; then
    # reset colors
    tput sgr0

    bold=$(tput bold)
    reset=$(tput sgr0)

    # Solarized colors, taken from http://git.io/solarized-colors.
    black=$(tput setaf 0)
    blue=$(tput setaf 33)
    #cyan=$(tput setaf 37)
    green=$(tput setaf 64)
    orange=$(tput setaf 166)
    #purple=$(tput setaf 125)
    red=$(tput setaf 124)
    violet=$(tput setaf 61)
    white=$(tput setaf 15)
    yellow=$(tput setaf 136)

     # Background colors for the segments
    #bg_blue=$(tput setab 33)
    bg_green=$(tput setab 64)
    bg_orange=$(tput setab 166)
    bg_red=$(tput setab 124)
    #bg_white=$(tput setab 15)
else
    bold=''
    reset="\e[0m"

    black="\e[1;30m"
    blue="\e[1;34m"
    #cyan="\e[1;36m"
    green="\e[1;32m"
    orange="\e[1;33m"
    #purple="\e[1;35m"
    red="\e[1;31m"
    violet="\e[1;35m"
    white="\e[1;37m"
    yellow="\e[1;33m"

    # Background colors (approximations)
    #bg_blue="\e[44m"
    bg_green="\e[42m"
    bg_orange="\e[43m"
    bg_red="\e[41m"
    #bg_white="\e[47m"
fi


# Powerline symbols (triangle/arrow)
if [[ "$LC_CTYPE" == *"UTF-8"* ]] || [[ "$LANG" == *"UTF-8"* ]] || [[ "$(locale charmap 2>/dev/null)" == "UTF-8" ]]; then
    # Unicode triangles (properly escaped for PS1)
    triangle_right=$'\uE0B0'      # 
    #top_left_corner=$'\u250F'     # ┏
    #bottom_left_corner=$'\u2517'  # ┗
    top_left_corner=$'\u256D'     # ╭
    #bottom_left_corner=$'\u2570'  # ╰
    bottom_left_corner="╰➤"      # Clean arrow
else
    # ASCII fallback
    triangle_right=">"
    top_left_corner="."
    bottom_left_corner="'"
fi

__prompt_git() {
    # Early returns for non-git directories

    # Check if the current directory is in a Git repository.
    git rev-parse --is-inside-work-tree &>/dev/null || return
    # check if the current directory is in .git before running git checks
    [ "$(git rev-parse --is-inside-git-dir 2>/dev/null)" == 'true' ] && return

    # Check what branch we’re on
    local branchName=$(git branch --show-current 2>/dev/null ||
                      git describe --all --exact-match HEAD 2>/dev/null ||
                      git rev-parse --short HEAD 2>/dev/null ||
                      echo '(unknown)')
    
    local status=$(git status --porcelain 2>/dev/null)
    local s=''
    
    # Check for staged changes (first character: M,A,D,R,C)
    [[ -n $(echo "$status" | grep '^[MADRC]') ]] && s+='+'
    # Check for unstaged changes (second character: M,A,D,R)
    [[ -n $(echo "$status" | grep '^.[MADR]') ]] && s+='!'
    # Check for untracked files (??)
    [[ -n $(echo "$status" | grep '^??') ]] && s+='?'
    # Check for stashed files
    git rev-parse --verify refs/stash &>/dev/null && s+='$'
    
    [ -n "$s" ] && s=" [$s]"
    printf "%s" "${1} ${branchName}${2}${s}"
}

# Exit status indicator
__exit_status() {
    local exit_code=$?
    [ $exit_code -ne 0 ] && printf "%s" "${red}✗${exit_code}${reset} " || printf "%s" "${green}✓${reset} "
}

# Virtual environment
__virtual_env() {
    [ -n "$VIRTUAL_ENV" ] && printf "%s" "${yellow}($(basename "$VIRTUAL_ENV"))${reset} "
}

# Multiline prompt
if [ "$color_prompt" = yes ]; then
    # Window title
    PS1="\[\e]0;\u@\h in \w\a\]"
    
    # LINE 1
    # corner
    PS1+="\[${orange}\]${top_left_corner}\[${reset}\]"
    # User@host segment
    PS1+="\[${bold}${bg_orange}${black}\] \u@\h\[${reset}\]"
    PS1+="\[${bg_green}${orange}\]${triangle_right}\[${reset}\]"
    # Current directory segment
    PS1+="\[${bg_green}${black}\] \w\[${reset}\]"
    PS1+="\[${green}\]${triangle_right}\[${reset}\]"

    # Git repository details
    PS1+="\$(__prompt_git \"\[${white}\] on \[${violet}\]\" \"\[${blue}\]\")"
    PS1+='\n'

    # LINE 2
    # corner
    PS1+="\[${orange}\]${bottom_left_corner}\[${reset}\]"

    PS1+='$(__virtual_env)'
    PS1+='\[${white}\]\$ \[${reset}\]'
else
    PS1='\u@\h:\w\$ '
fi

unset color_prompt
